# Mongoose CRUD

Refer to the repository: [Mongoose pokemon basics](https://github.com/thoughtworks-jumpstart/mongoose-pokemon-basics)

## Create

Use `save` to save in to the database.

```js
const createOne = async pokemon => {
  try {
    const newPokemon = new SimplePokemon(pokemon);
    await newPokemon.save();
  } catch (err) {
    handleError(err);
  }
};

createOne({
  name: "Pikachu",
  japaneseName: "ピカチュウ",
  baseHP: 35,
  category: "Mouse Pokemon",
});
```

The result is a document that is returned upon a successful save:

```
{
"_id":"5e26dfa7832a474fae143cda",
"name":"Pikachu",
"japaneseName":"ピカチュウ",
"baseHP":35,
"category":"Mouse Pokemon",
"__v":0
}
```

The following fields are returned (internal fields are prefixed with an underscore):

- The \_id field is auto-generated by Mongo and is a primary key of the collection. Its value is a unique identifier for the document.
- \_\_v is the versionKey property set on each document when first created by Mongoose. Its value contains the internal revision of the document.

If you try to repeat the save operation above, you will get a mongo error because we have specified that the name field should be unique. (and a unique index was created in the database)

```
{ MongoError: E11000 duplicate key error collection: pokedex.simplepokemons index: name_1 dup key: { name: "Pikachu" }
    at Function.create (/...)
  driver: true,
  name: 'MongoError',
  index: 0,
  code: 11000,
  keyPattern: { name: 1 },
  keyValue: { name: 'Pikachu' },
  errmsg:
   'E11000 duplicate key error collection: pokedex.simplepokemons index: name_1 dup key: { name: "Pikachu" }',
  [Symbol(mongoErrorContextSymbol)]: {} }
```

## Read

The document returned will be similar to what was displayed when we created the record.

It is an instance of Model and Document class of mongoose.

### Find

find is the the main way we query the database with mongoose. The first parameter of find is a **filter** object. If an empty object is passed or nothing is passed, then it will return all documents.

```js
await SimplePokemon.create([
  {
    name: "Pikachu",
    japaneseName: "ピカチュウ",
    baseHP: 35,
    category: "Mouse Pokemon",
  },
  {
    name: "Squirtle",
    japaneseName: "ゼニガメ",
    baseHP: 44,
    category: "Tiny Turtle Pokemon",
  },
  {
    name: "Wartortle",
    japaneseName: "カメール",
    baseHP: 59,
    category: "Turtle Pokémon",
  },
  {
    name: "Meowth",
    japaneseName: "ニャース",
    baseHP: 40,
    category: "Scratch Cat Pokémon",
  },
]);

const findAll = async () => {
  const foundPokemons = await SimplePokemon.find();
  return foundPokemons;
};
```

#### Query

find() returns a query. Mongoose queries are not promises. They have a `then()` function so that they can be used with async/await. However, unlike promises, calling a query's then() can execute the query multiple times.

[Read more about queries here](https://masteringjs.io/tutorials/mongoose/query) and in the [official documentation](https://mongoosejs.com/docs/queries.html).

```js
const query = SimplePokemon.find();
query instanceof mongoose.Query; // true

// Execute the query
const docs = await query;
```

#### basic filter

```js
const filteredPokemons = await SimplePokemon.find({ name: "Pikachu" });
```

### Query operator

We can use comparison operators `$lt`, `$gt`, `$lte`, and `$gte`

Less than:

```js
const filterHPGreaterThan = async HP => {
  const filteredPokemons = await SimplePokemon.find({
    baseHP: { $gt: HP },
  });
  return filteredPokemons;
};

filterHPGreaterThan(40).then(data => {
  console.log(`filterHPGreaterThan: ${data}`);
});
```

Now try to use `$lte` with a string. Strings will be compared using their unicode.

How do you sort the results?

#### Regular expression

Suppose you want to find characters whose rank contains 'turtle'. In SQL, you would use the LIKE operator. In Mongoose, you can simply query by a regular expression as shown below.

```js
const filterByCategory = async category => {
  const regex = new RegExp(category, "gi");
  const filteredPokemons = await SimplePokemon.find({ category: regex });
  return filteredPokemons;
};

filterByCategory("turtle").then(docs => {
  console.log(`filterByCategory: ${docs}`);

  // MongoDB may return the docs in any order unless you explicitly sort
  docs.map(doc => doc.name).sort();
});
```

```js
const docs = await SimplePokemon.find({
  category: { $eq: /turtle/ },
});
```

#### multiple filter

Match multiple filter properties (AND)

```js
const docs = await SimplePokemon.find({
  baseHP: { $gte: 39 },
  category: /turtle/,
});

docs.map(doc => doc.name);
```

### Find One

```js
const doc = await MyModel.findOne();

doc instanceof MyModel; // true
doc instanceof mongoose.Model; // true
doc instanceof mongoose.Document; // true
```

```js
const findOneByName = async name => {
  const foundPokemon = await SimplePokemon.findOne({ name: name });
  return foundPokemon;
};
```

## Update

### save()

```js
const schema = new mongoose.Schema({ name: String, title: String });
const CharacterModel = mongoose.model("Character", schema);

const doc = await CharacterModel.create({
  name: "Jon Snow",
  title: `Lord Commander of the Night's Watch`,
});

// Update the document by setting a property and calling `save()`
doc.title = "King in the North";
await doc.save();
```

First, save() is a method on a document, which means you must have a document to save. You need to either create() or use find() to get a document.

Second, Mongoose documents have change tracking. Under the hood, when you call doc.save(), Mongoose knows you set title and transforms your save() call into updateOne({ \$set: { title } }). Try running Mongoose with debug mode to see what queries Mongoose executes.

### updateOne and updateMany

Using Model.updateOne() and Model.updateMany(), you can update the document without loading it from the database first. **You should use save()** rather than updateOne() and updateMany() where possible. However, Model.updateOne() and Model.updateMany() have a few advantages:

- atomic. If you load a document using find(), it may change before you save() it.
- doesn't require you to load the document into memory, which may give you better performance if your documents are huge.

### What is atomicity?

An atomic operation is an operation that ensures whatever it is editing is only currently edited by the operation. When you want to update a document, atomicity means that the document is locked (not available to other operations) until the document is updated.

If we do not have atomicity,

1. Update document1 count++
2. Update document1 count++
   but if both runs at the same time and both operations found a document with count that is 4, both will add 1 to 4 and update the same document to 5. The final count will be 5 instead of 6.

### findOneAndUpdate

The Model.findOneAndUpdate() function behaves similarly to updateOne(): it atomically updates the first document that matches the first parameter filter.'

Model.findOneAndUpdate() Parameters

- filter / conditions
- update
- options
- callback

```js
const findOneAndUpdate = async (filter, update) => {
  // note that validation is false by default
  const pokemon = await SimplePokemon.findOneAndUpdate(
    filter,
    update,
    // If `new` isn't true, `findOneAndUpdate()` will return the
    // document as it was _before_ it was updated.
    { new: true }
  );
  return pokemon;
};

findOneAndUpdate({ name: "Squirtle" }, { baseHP: 100 }).then(data => {
  console.log(data);
});
```

This is actually send as a `$set` [field update](https://docs.mongodb.com/manual/reference/operator/update-field/).
This ensures that you do not override the entire document with `{ baseHP: 100 }`. Instead, the `baseHP` field is updated.

Note that by default, it does not run any validation nor does it create the object if it does not exist. Check the [official documentation](https://mongoosejs.com/docs/api.html#model_Model.findOneAndUpdate).

Setting the `runValidators` option lets it runs limited validation. If full validation is needed, we should use the `save()` method instead.

## Delete

```js
const deleteOneById = async id => {
  try {
    await SimplePokemon.findByIdAndDelete(id);
  } catch (err) {
    handleError(err);
  }
};

const deleteAll = async () => {
  try {
    await SimplePokemon.deleteMany();
  } catch (err) {
    handleError(err);
  }
};
```
